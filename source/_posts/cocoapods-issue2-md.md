---
title: CocoaPods Error —— 指定版本问题
date: 2015-12-10 20:28:30
tags: iOS
categories: development
copyright: true
---


> 使用pod安装依赖，其中`'xxxSDK'`仓库指定版本为`'1.2.1'`，但实际安装的版本是`'1.2.6'`。本文就此问题，探索一下原因。

<!--more-->

---

<br/>
# 场景
最近公司项目的某个模块做了大的改动，两组人在两个分支上进行并行开发。通过测试及功能验收后，产品部门打算将这两个大的功能改动作为一版本发布。

在合并代码过程中，`Podfile.lock`文件冲突，处理了冲突，发现执行`pod install`后提示`Podfile.lock`文件语法有问题。



<br/>
# 尝试解决问题
程序🐵偷懒天性使然，直接`mv Podfile.lock ~/.Trash`，再重新执行`pod install`。完美，安装成功，真是愉快的一天~~~

生活总是这么有趣，编译项目时发现`'xxxSDK'`的public接口找不到了。查询了下`'xxxSDK'`的版本更新日志，找找差异原因。原来是该框架在`'1.2.5'`版本进行重构，public接口的命名变了。为了不影响上线时间，决定将仓库指定为对于项目稳定的`'1.2.1'`。
```
pod 'xxxSDK', '~> 1.2.1'
```
重新执行`pod install`，编译项目发现依然找不到`'xxxSDK'`的`-autoLoginWith:`接口，真刺激！！！



<br/>
# 进一步分析问题
出现问题总是要解决的，接下来继续探索新问题...

从`github`直接将`'xxxSDK'`的代码仓库clone到本地。分别diff该仓库的各个tag分支和公司项目依赖的代码仓库（Tips：项目编译时依赖的代码仓库，位于项目路径下的Pods文件夹下），最后找到实际上目前项目依赖的代码依然是`'1.2.6'`版本。

不死心，继续尝试删掉`user/work/XXX/Pods/`目录下的依赖重新安装依赖
```
$ pod install --verbose
```
使用verbose option，等到install进程的更详细输出，从输出可以看到，重新安装依赖的版本依旧是`'1.2.6'`。

无奈之下只能去`CocoaPods`官网去查文档了，找到[有效信息](https://guides.cocoapods.org/using/the-podfile.html)。使用`~>`语法指定版本，`Podfile.lock`文件才会对`pod install`进程进行强制限制，而在开发过程中经常使用的`Podfile`文件主要作用建立依赖库的引用关系的，对于依赖的版本的限制相对较弱。

举个例子，例如版本`1.2.6`，主版本号是1，次版本号是2，修订版本号是6。`Podfile`文件只限制到次版本号，也就是说之前在`Podfile`文件指定为版本`'1.2.1'`，但是实际安装的依赖版本会是`'1.2.x'`次版本系列的修订版本号最大的仓库。看一下`Podfile.lock`文件的内容，
```
$ vim -R Podfile.lock
```
会看到`- xxxSDK (~> 1.2.6)`。



<br/>
# 解决问题
|方法一|方法二|
|---|---|
|将`Podfile.lock`文件中的`- xxxSDK (~> 1.2.6)`修改成`- xxxSDK (~> 1.2.1)`，重新安装依赖，nice，完美解决问题。|`Podfile`文件中的`pod 'xxxSDK', '~> 1.2.1'`修改成`pod 'xxxSDK', '1.2.1'`|


<br/>
# 总结
基于这个问题汇总了一下`CocoaPods`的`Podfile`文件的语法：

1.模糊版本指定:

    '> 0.1' —— 任一高于0.1版的包；
    '>= 0.1' —— 0.1版的包或任一高于0.1版的包；
    '< 0.1' —— 任一低于0.1版的包；
    '<= 0.1' —— 0.1版的包或任一低于0.1版的包；

2.乐观的版本指定（语法为`~>`）:

    '~> 0.1.2' —— 高于0.1.2，低于0.2的包；
    '~> 0.1' —— 高于0.1，低于1.0的包；
    '~> 0' —— 高于0，跟没有指定一样；

3.直接（强制）指定

	'0.1.2' —— 0.1.2版的包；

<br/>
# pick知识点
`CocoaPods`的版本控制基于[Semantic Versioning 2.0.0](https://semver.org/)，分为主版本、次版本、修订版本。

    主版本号：当你做了不兼容的 API 修改；
    次版本号：当你做了向下兼容的功能性新增；
    修订版本号：当你做了向下兼容的问题修正；

故相对规范的开源仓库，重新设计架构都会更新主版本号。建议各位玩开源的熊蝶再发布版本的时候注意一下[`CocoaPods所使用的版本准则`](https://semver.org/)。


# Tsukkomi
吐槽一下环信，一家付费提供IM服务的公司，于`3.3.7`到`3.3.8`版本修改了其SDK的public属性`[EMClient isLoggedIn]`的语义直接变更。

既然做付费服务，那么态度能否专业一点。




